name: Deploy JW Attendant Scheduler

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      commit-sha: ${{ github.sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Install dependencies
      run: npm ci
        
    - name: Build application
      run: npm run build
        
    - name: Create deployment package
      run: |
        mkdir -p deploy-package
        cp -r .next package.json package-lock.json prisma app deploy-package/
        if [ -d "public" ]; then cp -r public deploy-package/; fi
        echo "BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" > deploy-package/.build-info
        echo "COMMIT_SHA=${{ github.sha }}" >> deploy-package/.build-info
        tar -czf jw-attendant-scheduler-${{ github.sha }}.tar.gz -C deploy-package .
        
    - name: Upload deployment artifact
      uses: actions/upload-artifact@v4
      with:
        name: deployment-${{ github.sha }}
        path: jw-attendant-scheduler-${{ github.sha }}.tar.gz
        retention-days: 30

  deploy-staging:
    needs: build
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    runs-on: self-hosted
    environment: staging
    
    steps:
    - name: Download deployment artifact
      uses: actions/download-artifact@v4
      with:
        name: deployment-${{ needs.build.outputs.commit-sha }}
        
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy to staging
      run: |
        # Upload and extract
        scp jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz root@${{ secrets.STAGING_HOST }}:/tmp/
        
        # Deploy via SSH
        ssh root@${{ secrets.STAGING_HOST }} << 'EOF'
          set -e
          
          # Stop existing services
          pkill -f "next" || true
          
          # Create deployment directory
          mkdir -p /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }}
          
          # Extract new release
          cd /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }}
          tar -xzf /tmp/jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz
          
          # Install dependencies and build
          npm ci
          npm run build
          
          # Create environment file
          cat > .env.local << 'ENVEOF'
        DATABASE_URL=postgresql://postgres:Cl0udy!!(@)@10.92.3.21:5432/jw_attendant_scheduler_staging
        NEXTAUTH_SECRET=staging-secret-key
        NEXTAUTH_URL=http://${{ secrets.STAGING_HOST }}:3001
        ENVEOF
          
          # Update symlink atomically
          ln -sfn /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }} /opt/jw-attendant-scheduler/current
          
          # Start application
          cd /opt/jw-attendant-scheduler/current
          nohup npm start -- -p 3001 > /var/log/jw-attendant-scheduler.log 2>&1 &
          
          # Cleanup old releases (keep last 3)
          cd /opt/jw-attendant-scheduler/releases
          ls -t | tail -n +4 | xargs rm -rf
          
          # Cleanup temp file
          rm -f /tmp/jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz
        EOF
        
    - name: Health check
      run: |
        sleep 10
        curl -f http://${{ secrets.STAGING_HOST }}:3001 || (echo "Health check failed" && exit 1)
        
    - name: Deployment status
      run: |
        echo "âœ… Staging deployment successful"
        echo "ðŸ”— Staging URL: http://${{ secrets.STAGING_HOST }}:3001"

  deploy-production:
    needs: [build, deploy-staging]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    runs-on: self-hosted
    environment: production
    
    steps:
    - name: Download deployment artifact
      uses: actions/download-artifact@v4
      with:
        name: deployment-${{ needs.build.outputs.commit-sha }}
        
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        cp ~/.ssh/id_rsa_production ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy to production
      run: |
        # Upload and extract
        scp jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz root@${{ secrets.PRODUCTION_HOST }}:/tmp/
        
        # Deploy via SSH
        ssh root@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          set -e
          
          # Stop existing services
          pkill -f "next" || true
          
          # Create deployment directory
          mkdir -p /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }}
          
          # Extract new release
          cd /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }}
          tar -xzf /tmp/jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz
          
          # Install only production dependencies (lighter than full build)
          npm ci --only=production
          
          # Create environment file (production uses separate database)
          cat > .env.local << 'ENVEOF'
        DATABASE_URL=postgresql://postgres:Cl0udy!!(@)@10.92.3.21:5432/jw_scheduler_prod
        NEXTAUTH_SECRET=production-secret-key
        NEXTAUTH_URL=http://${{ secrets.PRODUCTION_HOST }}:3001
        ENVEOF
          
          # Update symlink atomically
          ln -sfn /opt/jw-attendant-scheduler/releases/${{ needs.build.outputs.commit-sha }} /opt/jw-attendant-scheduler/current
          
          # Start application (use pre-built artifacts)
          cd /opt/jw-attendant-scheduler/current
          nohup npx next start -p 3001 > /var/log/jw-attendant-scheduler.log 2>&1 &
          
          # Cleanup old releases (keep last 3)
          cd /opt/jw-attendant-scheduler/releases
          ls -t | tail -n +4 | xargs rm -rf
          
          # Cleanup temp file
          rm -f /tmp/jw-attendant-scheduler-${{ needs.build.outputs.commit-sha }}.tar.gz
        EOF
        
    - name: Health check
      run: |
        sleep 10
        curl -f http://${{ secrets.PRODUCTION_HOST }}:3001 || (echo "Health check failed" && exit 1)
        
    - name: Deployment status
      run: |
        echo "âœ… Production deployment successful"
        echo "ðŸ”— Production URL: http://${{ secrets.PRODUCTION_HOST }}:3001"
