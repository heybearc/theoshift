generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model assignments {
  id              String           @id
  eventId         String
  userId          String
  positionId      String
  shiftId         String?
  shiftStart      DateTime
  shiftEnd        DateTime
  status          AssignmentStatus @default(ASSIGNED)
  notes           String?
  assignedBy      String?
  assignedAt      DateTime         @default(now())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime
  events          events           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  event_positions event_positions  @relation(fields: [positionId], references: [id], onDelete: Cascade)
  users           users            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// CONSOLIDATED MODEL: All attendant data is now event-scoped
model event_attendants {
  id                          String      @id
  eventId                     String
  userId                      String?     // Optional link to user account
  
  // Personal Information (consolidated from attendants table)
  firstName                   String
  lastName                    String
  email                       String
  phone                       String?
  congregation                String
  
  // Availability & Status
  isActive                    Boolean     @default(true)
  isAvailable                 Boolean     @default(true)
  availabilityStatus          String?     @default("AVAILABLE")
  
  // Service Information
  formsOfService              Json        @default("[]")
  servingAs                   Json?       @default("[]")
  skills                      Json?
  preferredDepartments        Json?
  unavailableDates            Json?
  
  // Event-Specific Data
  role                        UserRole    @default(ATTENDANT)
  assignedDepartments         Json?
  assignedStationRanges       Json?
  
  // Authentication
  pinHash                     String?
  profileVerificationRequired Boolean     @default(false)
  profileVerifiedAt           DateTime?
  
  // Statistics
  totalAssignments            Int         @default(0)
  totalHours                  Float       @default(0)
  
  // Metadata
  notes                       String?
  createdAt                   DateTime    @default(now())
  updatedAt                   DateTime    @updatedAt
  
  // Relations
  events                      events      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  users                       users?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Position assignments now reference event_attendants directly
  position_assignments        position_assignments[]
  keyman_assignments          position_assignments[]           @relation("KeymanRelation")
  overseer_assignments        position_assignments[]           @relation("OverseerRelation")
  
  // Oversight assignments
  position_keyman             position_oversight_assignments[] @relation("KeymanAssignments")
  position_overseer           position_oversight_assignments[] @relation("OverseerAssignments")
  
  // Document publications
  document_publications       document_publications[]

  @@unique([eventId, userId])
  @@unique([eventId, email])  // Prevent duplicate emails per event
  @@index([eventId])
  @@index([email])
  @@index([eventId, isActive])
}

model count_sessions {
  id              String             @id
  eventId         String
  sessionName     String
  countTime       DateTime
  notes           String?
  isActive        Boolean            @default(true)
  status          CountSessionStatus @default(ACTIVE)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime
  createdBy       String?
  uploadedAt      DateTime           @default(now())
  uploadedBy      String?
  events          events             @relation(fields: [eventId], references: [id])
  position_counts position_counts[]

  @@unique([eventId, sessionName])
}

model email_configurations {
  id                 String   @id
  smtpServer         String
  smtpPort           Int
  smtpUser           String
  smtpPassword       String
  fromEmail          String
  fromName           String
  replyToEmail       String?
  inviteTemplate     String?
  assignmentTemplate String?
  reminderTemplate   String?
  isActive           Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime
}

model event_positions {
  id                   String            @id
  eventId              String
  positionNumber       Int
  positionName         String
  description          String?
  department           String?
  isActive             Boolean           @default(true)
  isAllDay             Boolean           @default(false)
  isLeadershipPosition Boolean           @default(false)
  requiresExperience   Boolean           @default(false)
  maxAttendants        Int               @default(1)
  minAttendants        Int               @default(1)
  tags                 Json?
  instructions         String?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime
  assignments          assignments[]
  events               events            @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, positionNumber])
}

model events {
  id                           String                           @id
  name                         String
  description                  String?
  startDate                    DateTime
  endDate                      DateTime
  location                     String?
  status                       EventStatus                      @default(UPCOMING)
  type                         EventType                        @default(CIRCUIT_ASSEMBLY)
  maxAttendants                Int?
  registrationDeadline         DateTime?
  isPublic                     Boolean                          @default(false)
  settings                     Json?
  createdAt                    DateTime                         @default(now())
  updatedAt                    DateTime
  createdBy                    String?
  assignments                  assignments[]
  count_sessions               count_sessions[]
  event_attendants             event_attendants[]
  event_positions              event_positions[]
  lanyards                     lanyards[]
  position_assignments         position_assignments[]
  position_oversight_assignments position_oversight_assignments[]
  positions                    positions[]
  users                        users?                           @relation(fields: [createdBy], references: [id])
  event_documents              event_documents[]
  event_permissions            event_permissions[]

  @@index([startDate])
  @@index([status])
  @@index([createdBy])
}

model lanyards {
  id        String        @id
  eventId   String
  number    Int
  color     String?
  status    LanyardStatus @default(AVAILABLE)
  issuedTo  String?
  issuedAt  DateTime?
  returnedAt DateTime?
  notes     String?
  createdAt DateTime      @default(now())
  updatedAt DateTime
  events    events        @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, number])
}

// Updated to reference event_attendants instead of attendants
model position_assignments {
  id           String            @id
  positionId   String
  eventId      String
  attendantId  String            // Now references event_attendants.id
  role         PositionRole      @default(ATTENDANT)
  shiftId      String?
  shiftStart   DateTime?
  shiftEnd     DateTime?
  status       AssignmentStatus  @default(ASSIGNED)
  notes        String?
  assignedBy   String?
  assignedAt   DateTime?         @default(now())
  createdAt    DateTime?         @default(now()) @db.Timestamp(6)
  updatedAt    DateTime?         @default(now()) @updatedAt @db.Timestamp(6)
  overseerId   String?
  keymanId     String?
  
  // Relations now point to event_attendants
  attendant    event_attendants  @relation(fields: [attendantId], references: [id], onDelete: Cascade)
  keyman       event_attendants? @relation("KeymanRelation", fields: [keymanId], references: [id])
  overseer     event_attendants? @relation("OverseerRelation", fields: [overseerId], references: [id])
  
  assignedByUser users?          @relation("AssignedByUser", fields: [assignedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
  event        events            @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  position     positions         @relation(fields: [positionId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([positionId, attendantId])
  @@index([eventId], map: "idx_position_assignments_event")
  @@index([attendantId], map: "idx_position_assignments_attendant")
  @@index([positionId], map: "idx_position_assignments_position")
}

model positions {
  id                           String                           @id
  eventId                      String
  positionNumber               Int
  name                         String
  area                         String?
  description                  String?
  isActive                     Boolean                          @default(true)
  isAllDay                     Boolean                          @default(false)
  isLeadershipPosition         Boolean                          @default(false)
  requiresExperience           Boolean                          @default(false)
  experienceLevel              ExperienceLevel?
  maxAttendants                Int                              @default(1)
  minAttendants                Int                              @default(1)
  tags                         Json?
  instructions                 String?
  shifts                       Json?
  createdAt                    DateTime                         @default(now())
  updatedAt                    DateTime
  events                       events                           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  position_assignments         position_assignments[]
  position_counts              position_counts[]
  position_oversight_assignments position_oversight_assignments[]

  @@unique([eventId, positionNumber])
  @@index([eventId], map: "idx_positions_event")
  @@index([area], map: "idx_positions_area")
}

model position_counts {
  id             String         @id
  sessionId      String
  positionId     String
  count          Int            @default(0)
  notes          String?
  countedAt      DateTime?
  countedBy      String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime
  count_sessions count_sessions @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  position       positions      @relation(fields: [positionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, positionId])
}

// Updated to reference event_attendants instead of attendants
model position_oversight_assignments {
  id         String            @id
  positionId String            @map("position_id")
  eventId    String            @map("event_id")
  overseerId String?           @map("overseer_id")  // Now references event_attendants.id
  keymanId   String?           @map("keyman_id")    // Now references event_attendants.id
  assignedBy String?           @map("assigned_by")
  createdAt  DateTime?         @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt  DateTime?         @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)
  
  // Relations now point to event_attendants
  keyman     event_attendants? @relation("KeymanAssignments", fields: [keymanId], references: [id], onUpdate: NoAction)
  overseer   event_attendants? @relation("OverseerAssignments", fields: [overseerId], references: [id], onUpdate: NoAction)
  
  assignedByUser users?        @relation("AssignedByUser", fields: [assignedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
  event      events            @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  position   positions         @relation(fields: [positionId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([positionId, eventId])
  @@index([eventId], map: "idx_position_oversight_event")
  @@index([keymanId], map: "idx_position_oversight_keyman")
  @@index([overseerId], map: "idx_position_oversight_overseer")
  @@index([positionId], map: "idx_position_oversight_position")
}

model event_documents {
  id             String                  @id @default(cuid())
  eventId        String
  title          String
  description    String?
  fileName       String
  fileUrl        String
  fileType       String
  fileSize       Int
  uploadedBy     String
  uploadedAt     DateTime                @default(now())
  publishedTo    String                  @default("none")
  publishedCount Int                     @default(0)
  publishedAt    DateTime?
  isActive       Boolean                 @default(true)
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  publications   document_publications[]
  events         events                  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId], map: "idx_event_documents_event")
  @@index([uploadedBy], map: "idx_event_documents_uploader")
}

// Updated to reference event_attendants instead of attendants
model document_publications {
  id           String           @id @default(cuid())
  documentId   String
  attendantId  String           // Now references event_attendants.id
  publishedAt  DateTime         @default(now())
  viewedAt     DateTime?
  downloadedAt DateTime?
  
  // Relations now point to event_attendants
  attendant    event_attendants @relation(fields: [attendantId], references: [id], onDelete: Cascade)
  document     event_documents  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, attendantId])
  @@index([documentId], map: "idx_document_publications_document")
  @@index([attendantId], map: "idx_document_publications_attendant")
}

model feedback {
  id          String                 @id @default(cuid())
  type        FeedbackType
  title       String
  description String
  priority    FeedbackPriority       @default(MEDIUM)
  status      FeedbackStatus         @default(NEW)
  submittedBy String
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  user        users                  @relation(fields: [submittedBy], references: [id], onDelete: Cascade)
  attachments feedback_attachments[]
  comments    feedback_comments[]

  @@map("feedback")
}

model feedback_attachments {
  id         String   @id @default(cuid())
  feedbackId String
  filename   String
  filePath   String
  fileSize   Int
  mimeType   String
  createdAt  DateTime @default(now())
  feedback   feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)

  @@map("feedback_attachments")
}

model feedback_comments {
  id         String   @id @default(cuid())
  feedbackId String
  authorId   String
  content    String
  createdAt  DateTime @default(now())
  author     users    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  feedback   feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)

  @@map("feedback_comments")
}

model event_permissions {
  id        String              @id @default(uuid())
  userId    String
  eventId   String
  role      EventPermissionRole @default(VIEWER)
  scopeType EventScopeType?
  scopeIds  Json?
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  event     events              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      users               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([eventId, role])
}

model users {
  id                              String                           @id @default(cuid())
  firstName                       String
  lastName                        String
  email                           String                           @unique
  role                            UserRole                         @default(ATTENDANT)
  isActive                        Boolean                          @default(true)
  lastLogin                       DateTime?
  createdAt                       DateTime                         @default(now())
  updatedAt                       DateTime                         @updatedAt
  assignments                     assignments[]
  event_attendants                event_attendants[]
  events                          events[]
  position_assignments_assigned   position_assignments[]           @relation("AssignedByUser")
  position_oversight_assigned     position_oversight_assignments[] @relation("AssignedByUser")
  feedback                        feedback[]
  feedback_comments               feedback_comments[]
  event_permissions               event_permissions[]

  @@map("users")
}

// Enums remain the same
enum AssignmentStatus {
  ASSIGNED
  CONFIRMED
  DECLINED
  COMPLETED
  NO_SHOW
}

enum CountSessionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

enum DocumentAccessLevel {
  PUBLIC
  ATTENDANTS_ONLY
  LEADERSHIP_ONLY
  DEPARTMENT_SPECIFIC
  POSITION_SPECIFIC
  ADMIN_ONLY
}

enum DocumentCategory {
  EMERGENCY_INFO
  POSITION_INSTRUCTIONS
  EVENT_DOCUMENTATION
  TRAINING_MATERIALS
  ANNOUNCEMENTS
  FORMS
  REPORTS
  OTHER
}

enum EventStatus {
  UPCOMING
  CURRENT
  COMPLETED
  CANCELLED
  ARCHIVED
}

enum EventType {
  CIRCUIT_ASSEMBLY
  REGIONAL_CONVENTION
  SPECIAL_EVENT
  OTHER
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  EXPERIENCED
  EXPERT
}

enum LanyardStatus {
  AVAILABLE
  CHECKED_OUT
  LOST
  DAMAGED
  RETIRED
}

enum OversightLevel {
  OVERSEER
  ASSISTANT_OVERSEER
  DEPARTMENT_HEAD
  STATION_OVERSEER
}

enum UserRole {
  ADMIN
  OVERSEER
  ASSISTANT_OVERSEER
  KEYMAN
  ATTENDANT
}

enum PositionRole {
  OVERSEER
  KEYMAN
  ATTENDANT
}

enum FeedbackType {
  BUG
  ENHANCEMENT
  FEATURE
}

enum FeedbackPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum FeedbackStatus {
  NEW
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum EventPermissionRole {
  OWNER
  MANAGER
  OVERSEER
  KEYMAN
  VIEWER
}

enum EventScopeType {
  DEPARTMENT
  STATION_RANGE
  POSITION
}
